#!/bin/bash
#======================================================================================
# Function: Update openwrt to emmc for Amlogic S9xxx STB
# Copyright (C) 2020-- https://github.com/unifreq/openwrt_packit
# Copyright (C) 2021-- https://github.com/ophub/luci-app-amlogic
#======================================================================================

# The script supports directly setting parameters for update, skipping interactive selection
# openwrt-update-amlogic ${OPENWRT_FILE} ${AUTO_MAINLINE_UBOOT} ${RESTORE_CONFIG}
# E.g: openwrt-update-amlogic openwrt_s905d.img.gz yes restore
# E.g: openwrt-update-amlogic openwrt_s905d.img.gz no no-restore

# You can also execute the script directly, and interactively select related functions
# E.g: openwrt-update-amlogic

# Receive one-key command related parameters
IMG_NAME=${1}
AUTO_MAINLINE_UBOOT=${2}
BACKUP_RESTORE_CONFIG=${3}

# Current device model
MYDEVICE_NAME=$(cat /proc/device-tree/model | tr -d '\000')
if [[ -z "${MYDEVICE_NAME}" ]]; then
    echo "The device name is empty and cannot be recognized."
    exit 1
elif [[ ! -f "/etc/flippy-openwrt-release" ]]; then
    echo "The [ /etc/flippy-openwrt-release ] file is missing."
    exit 1
else
    echo -e "Current device: ${MYDEVICE_NAME} [ amlogic ]"
    sleep 3
fi

EMMC_NAME=$(lsblk -l -o NAME | grep -oE '(mmcblk[0-9]?boot0)' | sed "s/boot0//g")
if [ "${EMMC_NAME}" == "" ]; then
    echo "The system did not find any available disk devices!!!"
    exit 1
fi

cd /mnt/${EMMC_NAME}p4/
mv -f /tmp/upload/* . 2>/dev/null && sync
mv -f .tmp_upload/* . 2>/dev/null && sync

if [[ "${IMG_NAME}" == *.img ]]; then
    echo -e "Update using [ ${IMG_NAME} ] file. Please wait a moment ..."
elif [ $( ls *.img -l 2>/dev/null | grep "^-" | wc -l ) -ge 1 ]; then
    IMG_NAME=$( ls *.img | head -n 1 )
    echo -e "Update using [ ${IMG_NAME} ] ] file. Please wait a moment ..."
elif [ $( ls *.img.xz -l 2>/dev/null | grep "^-" | wc -l ) -ge 1 ]; then
    xz_file=$( ls *.img.xz | head -n 1 )
    echo -e "Update using [ ${xz_file} ] file. Please wait a moment ..."
    xz -d ${xz_file} 2>/dev/null
    IMG_NAME=$( ls *.img | head -n 1 )
elif [ $( ls *.img.gz -l 2>/dev/null | grep "^-" | wc -l ) -ge 1 ]; then
    gz_file=$( ls *.img.gz | head -n 1 )
    echo -e "Update using [ ${gz_file} ] file. Please wait a moment ..."
    gzip -df ${gz_file} 2>/dev/null
    IMG_NAME=$( ls *.img | head -n 1 )
elif [ $( ls *.7z -l 2>/dev/null | grep "^-" | wc -l ) -ge 1 ]; then
    gz_file=$( ls *.7z | head -n 1 )
    echo -e "Update using [ ${gz_file} ] file. Please wait a moment ..."
    bsdtar -xmf ${gz_file} 2>/dev/null
    [ $? -eq 0 ] || 7z x ${gz_file} -aoa -y 2>/dev/null
    IMG_NAME=$( ls *.img | head -n 1 )
elif [ $( ls *.zip -l 2>/dev/null | grep "^-" | wc -l ) -ge 1 ]; then
    zip_file=$( ls *.zip | head -n 1 )
    echo -e "Update using [ ${zip_file} ] file. Please wait a moment ..."
    unzip -o ${zip_file} 2>/dev/null
    IMG_NAME=$( ls *.img | head -n 1 )
else
    echo -e "Please upload or specify the update openwrt firmware file."
    echo -e "Upload method: system menu → Amlogic Service → Manually Upload Update"
    echo -e "Specify method: Place the openwrt firmware file in [ /mnt/${EMMC_NAME}p4/ ]"
    echo -e "The supported file suffixes are: *.img, *.img.xz, *.img.gz, *.7z, *.zip"
    echo -e "After upload the openwrt firmware file, run again."
    exit 1
fi
sync

# check file
if  [ ! -f "${IMG_NAME}" ]; then
    echo "No update file found."
    exit 1
else
    echo "Start update from [ ${IMG_NAME} ]"
fi

# Check the necessary dependencies
DEPENDS="lsblk uuidgen grep awk btrfs mkfs.fat mkfs.btrfs perl md5sum"
echo "Check the necessary dependencies..."
for dep in ${DEPENDS};do
    WITCH=$(which ${dep})
    if [ "${WITCH}" == "" ];then
        echo "Dependent command: ${dep} does not exist, upgrade cannot be performed, only flash through U disk/TF card!"
        exit 1
    else
        echo "${dep} path: ${WITCH}"
    fi
done
echo "Check passed"

# find boot partition 
BOOT_PART_MSG=$(lsblk -l -o NAME,PATH,TYPE,UUID,MOUNTPOINT | awk '$3~/^part$/ && $5 ~ /^\/boot$/ {print $0}')
if  [ "${BOOT_PART_MSG}" == "" ]; then
    echo "Boot The partition does not exist, so the update cannot be continued!"
    exit 1
fi
BOOT_NAME=$(echo $BOOT_PART_MSG | awk '{print $1}')
BOOT_PATH=$(echo $BOOT_PART_MSG | awk '{print $2}')
BOOT_UUID=$(echo $BOOT_PART_MSG | awk '{print $4}')

BR_FLAG=1
echo -ne "Whether to backup and restore the current config files? y/n [y]\b\b"
if [[ ${BACKUP_RESTORE_CONFIG} == "restore" ]]; then
    yn="y"
elif [[ ${BACKUP_RESTORE_CONFIG} == "no-restore" ]]; then
    yn="n"
else
    read yn
fi
case $yn in
     n*|N*) BR_FLAG=0;;
esac

# find root partition 
ROOT_PART_MSG=$(lsblk -l -o NAME,PATH,TYPE,UUID,MOUNTPOINT | awk '$3~/^part$/ && $5 ~ /^\/$/ {print $0}')
ROOT_NAME=$(echo $ROOT_PART_MSG | awk '{print $1}')
ROOT_PATH=$(echo $ROOT_PART_MSG | awk '{print $2}')
ROOT_UUID=$(echo $ROOT_PART_MSG | awk '{print $4}')

case  $ROOT_NAME in
      ${EMMC_NAME}p2) NEW_ROOT_NAME=${EMMC_NAME}p3
                      NEW_ROOT_LABEL=EMMC_ROOTFS2
                      ;;
      ${EMMC_NAME}p3) NEW_ROOT_NAME=${EMMC_NAME}p2
                      NEW_ROOT_LABEL=EMMC_ROOTFS1
                      ;;
                   *) echo "ROOTFS The partition location is incorrect, so the update cannot continue!"
                      exit 1
                      ;;
esac
echo "NEW_ROOT_NAME: [ ${NEW_ROOT_NAME} ]"

# find new root partition
NEW_ROOT_PART_MSG=$(lsblk -l -o NAME,PATH,TYPE,UUID,MOUNTPOINT | grep "${NEW_ROOT_NAME}" | awk '$3 ~ /^part$/ && $5 !~ /^\/$/ && $5 !~ /^\/boot$/ {print $0}')
if  [ "${NEW_ROOT_PART_MSG}" == "" ]; then
    echo "The new ROOTFS partition does not exist, so the update cannot continue!"
    exit 1
fi
NEW_ROOT_NAME=$(echo $NEW_ROOT_PART_MSG | awk '{print $1}')
NEW_ROOT_PATH=$(echo $NEW_ROOT_PART_MSG | awk '{print $2}')
NEW_ROOT_UUID=$(echo $NEW_ROOT_PART_MSG | awk '{print $4}')
NEW_ROOT_MP=$(echo $NEW_ROOT_PART_MSG | awk '{print $5}')
echo "NEW_ROOT_MP: [ ${NEW_ROOT_MP} ]"

# backup old bootloader
if  [ ! -f /root/BackupOldBootloader.img ]; then
    echo "Backup bootloader -> [ BackupOldBootloader.img ] ... "
    dd if=/dev/${EMMC_NAME} of=/root/BackupOldBootloader.img bs=1M count=4 conv=fsync
    echo "Backup bootloader complete."
    echo
fi

# losetup
losetup -f -P $IMG_NAME
if  [ $? -eq 0 ]; then
    LOOP_DEV=$(losetup | grep "$IMG_NAME" | awk '{print $1}')
    if  [ "$LOOP_DEV" == "" ]; then
        echo "loop device not found!"
        exit 1
    fi
else
    echo "losetup [ $IMG_FILE ] failed!"
    exit 1
fi

WAIT=3
echo "The loopdev is [ $LOOP_DEV ], wait [ ${WAIT} ] seconds. "
while [ $WAIT -ge 1 ]; do
      sleep 1
      WAIT=$(( WAIT - 1 ))
done

# umount loop devices (openwrt will auto mount some partition)
MOUNTED_DEVS=$(lsblk -l -o NAME,PATH,MOUNTPOINT | grep "$LOOP_DEV" | awk '$3 !~ /^$/ {print $2}')
for dev in $MOUNTED_DEVS; do
    while : ; do
        echo "umount [ $dev ] ... "
        umount -f $dev
        sleep 1
        mnt=$(lsblk -l -o NAME,PATH,MOUNTPOINT | grep "$dev" | awk '$3 !~ /^$/ {print $2}')
        if  [ "$mnt" == "" ]; then
            break
        else 
            echo "Retry ..."
        fi
    done
done

# mount src part
WORK_DIR=$PWD
P1=${WORK_DIR}/boot
P2=${WORK_DIR}/root
mkdir -p $P1 $P2

echo "Mount [ ${LOOP_DEV}p1 ] -> [ ${P1} ] ... "
mount -t vfat -o ro ${LOOP_DEV}p1 ${P1}
if  [ $? -ne 0 ]; then
    echo "Mount p1 [ ${LOOP_DEV}p1 ] failed!"
    losetup -D
    exit 1
fi

echo "Mount [ ${LOOP_DEV}p2 ] -> [ ${P2} ] ... "
mount -t btrfs -o ro,compress=zstd ${LOOP_DEV}p2 ${P2}
if  [ $? -ne 0 ]; then
    echo "Mount p2 [ ${LOOP_DEV}p2 ] failed!"
    umount -f ${P1}
    losetup -D
    exit 1
fi

#update version prompt
source /boot/uEnv.txt 2>/dev/null
CUR_FDTFILE=${FDT}
echo -e "FDT Value [ ${CUR_FDTFILE} ]"
cp /boot/uEnv.txt /tmp/uEnv.txt && sync

MODULES_OLD=$(ls /lib/modules/ 2>/dev/null)
VERSION_OLD=$(echo ${MODULES_OLD} | grep -oE '^[1-9].[0-9]{1,3}' 2>/dev/null)
MODULES_NOW=$(ls ${P2}/lib/modules/ 2>/dev/null)
VERSION_NOW=$(echo ${MODULES_NOW} | grep -oE '^[1-9].[0-9]{1,3}' 2>/dev/null)
echo -e "Update from [ ${MODULES_OLD} ] to [ ${MODULES_NOW} ]"

k510_ver=${VERSION_NOW%%.*}
k510_maj=${VERSION_NOW##*.}
if  [ "${k510_ver}" -eq "5" ];then
    if  [ "${k510_maj}" -ge "10" ];then
        K510="1"
    else
        K510="0"
    fi
elif [ "${k510_ver}" -gt "5" ];then
    K510="1"
else
    K510="0"
fi

# flippy-openwrt-release info
UBOOT_OVERLOAD=""
MAINLINE_UBOOT=""
ANDROID_UBOOT=""
env_openwrt_file=""

if  [ -f "${P2}/etc/flippy-openwrt-release" ]; then
    env_openwrt_file="${P2}/etc/flippy-openwrt-release"
elif [ -f "/etc/flippy-openwrt-release" ]; then
    env_openwrt_file="/etc/flippy-openwrt-release"
else
    env_openwrt_file=""
fi

if [ -n "${env_openwrt_file}" ]; then
    source "${env_openwrt_file}" 2>/dev/null
    # Update the parameters used
    UBOOT_OVERLOAD=${UBOOT_OVERLOAD}
    MAINLINE_UBOOT=${MAINLINE_UBOOT}
    ANDROID_UBOOT=${ANDROID_UBOOT}

    # Unused parameters
    FDTFILE=${FDTFILE}
    U_BOOT_EXT=${U_BOOT_EXT}
    KERNEL_VERSION=${KERNEL_VERSION}
    SOC=${SOC}

    # With assigned parameters
    #K510=${K510}
fi

#format NEW_ROOT
echo "umount [ ${NEW_ROOT_MP} ]"
umount -f "${NEW_ROOT_MP}"
if  [ $? -ne 0 ]; then
    echo "Mount [ ${NEW_ROOT_MP} ] failed, Please restart and try again!"
    umount -f ${P1}
    umount -f ${P2}
    losetup -D
    exit 1
fi

echo "Format [ ${NEW_ROOT_PATH} ]"
NEW_ROOT_UUID=$(uuidgen)
mkfs.btrfs -f -U ${NEW_ROOT_UUID} -L ${NEW_ROOT_LABEL} -m single ${NEW_ROOT_PATH}
if  [ $? -ne 0 ]; then
    echo "Format [ ${NEW_ROOT_PATH} ] failed!"
    umount -f ${P1}
    umount -f ${P2}
    losetup -D
    exit 1
fi

echo "Mount [ ${NEW_ROOT_PATH} ] -> [ ${NEW_ROOT_MP} ]"
mount -t btrfs -o compress=zstd ${NEW_ROOT_PATH} ${NEW_ROOT_MP}
if  [ $? -ne 0 ]; then
    echo "Mount [ ${NEW_ROOT_PATH} ] -> [ ${NEW_ROOT_MP} ] failed!"
    umount -f ${P1}
    umount -f ${P2}
    losetup -D
    exit 1
fi

# begin copy rootfs
cd ${NEW_ROOT_MP}
echo "Start copying data， From [ ${P2} ] TO [ ${NEW_ROOT_MP} ] ..."
ENTRYS=$(ls)
for entry in $ENTRYS; do
    if  [ "$entry" == "lost+found" ]; then
        continue
    fi
    echo "Remove old [ $entry ] ... "
    rm -rf $entry 
    if  [ $? -ne 0 ]; then
        echo "failed."
        exit 1
    fi
done

echo "Create folder ... "
btrfs subvolume create etc
mkdir -p .snapshots .reserved bin boot dev lib opt mnt overlay proc rom root run sbin sys tmp usr www
ln -sf lib/ lib64
ln -sf tmp/ var
sync

COPY_SRC="root etc bin sbin lib opt usr www"
echo "Copy data begin ... "
for src in $COPY_SRC; do
    echo "Copy [ $src ] ... "
    (cd ${P2} && tar cf - $src) | tar xf -
    sync
done

cat > ./etc/fstab <<EOF
UUID=${NEW_ROOT_UUID} / btrfs compress=zstd 0 1
LABEL=EMMC_BOOT /boot vfat defaults 0 2
#tmpfs /tmp tmpfs defaults,nosuid 0 0
EOF

cat > ./etc/config/fstab <<EOF
config  global
        option anon_swap '0'
        option anon_mount '1'
        option auto_swap '0'
        option auto_mount '1'
        option delay_root '5'
        option check_fs '0'

config  mount
        option target '/overlay'
        option uuid '${NEW_ROOT_UUID}'
        option enabled '1'
        option enabled_fsck '1'
        option fstype 'btrfs'
        option options 'compress=zstd'

config  mount
        option target '/boot'
        option label 'EMMC_BOOT'
        option enabled '1'
        option enabled_fsck '1'
        option fstype 'vfat'

EOF
(
    cd etc/rc.d 
    rm -f S??shortcut-fe
    if grep "sfe_flow '1'" ../config/turboacc >/dev/null;then
        if find ../../lib/modules -name 'shortcut-fe-cm.ko';then
            ln -sf ../init.d/shortcut-fe S99shortcut-fe
        fi
    fi
)
sync

echo "Create initial etc snapshot -> .snapshots/etc-000"
btrfs subvolume snapshot -r etc .snapshots/etc-000
sync

[ -d /mnt/${EMMC_NAME}p4/docker ] || mkdir -p /mnt/${EMMC_NAME}p4/docker
rm -rf opt/docker && ln -sf /mnt/${EMMC_NAME}p4/docker/ opt/docker

if  [ -f /mnt/${NEW_ROOT_NAME}/etc/config/AdGuardHome ]; then
    [ -d /mnt/${EMMC_NAME}p4/AdGuardHome/data ] || mkdir -p /mnt/${EMMC_NAME}p4/AdGuardHome/data
    if  [ ! -L /usr/bin/AdGuardHome ]; then
        [ -d /usr/bin/AdGuardHome ] && \
        cp -a /usr/bin/AdGuardHome/* /mnt/${EMMC_NAME}p4/AdGuardHome/
    fi
    ln -sf /mnt/${EMMC_NAME}p4/AdGuardHome /mnt/${NEW_ROOT_NAME}/usr/bin/AdGuardHome
fi

#rm -f /mnt/${NEW_ROOT_NAME}/usr/sbin/openwrt-install-amlogic
#rm -f /mnt/${NEW_ROOT_NAME}/usr/sbin/openwrt-update-amlogic
rm -f /mnt/${NEW_ROOT_NAME}/root/install-to-emmc.sh
sync
echo "Copy data complete ..."

BACKUP_LIST=$(${P2}/usr/sbin/openwrt-backup -p)
if [[ "${BR_FLAG}" -eq "1" && -n "${BACKUP_LIST}" ]];then
    echo -n "Start restoring configuration files ... "
    (
      cd /
      eval tar czf ${NEW_ROOT_MP}/.reserved/openwrt_config.tar.gz "${BACKUP_LIST}" 2>/dev/null
    )
    tar xzf ${NEW_ROOT_MP}/.reserved/openwrt_config.tar.gz

    [ -f ./etc/config/dockerman ] && sed -e "s/option wan_mode 'false'/option wan_mode 'true'/" -i ./etc/config/dockerman 2>/dev/null
    [ -f ./etc/config/dockerd ] && sed -e "s/option wan_mode '0'/option wan_mode '1'/" -i ./etc/config/dockerd 2>/dev/null
    [ -f ./etc/config/verysync ] && sed -e 's/config setting/config verysync/' -i ./etc/config/verysync 2>/dev/null

    # Restore fstab
    cp -f .snapshots/etc-000/fstab ./etc/fstab
    cp -f .snapshots/etc-000/config/fstab ./etc/config/fstab
    sync
    echo "Restore configuration information complete."
fi

echo "Modify the configuration file ... "
rm -f "./etc/rc.local.orig" "./usr/bin/mk_newpart.sh" "./etc/part_size"
rm -rf "./opt/docker" && ln -sf "/mnt/${EMMC_NAME}p4/docker" "./opt/docker"
rm -f ./etc/bench.log
cat >> ./etc/crontabs/root << EOF
37 5 * * * /etc/coremark.sh
EOF

sed -e 's/ttyAMA0/ttyAML0/' -i ./etc/inittab
sed -e 's/ttyS0/tty0/' -i ./etc/inittab

# Fix the problem of repeatedly adding sshd entries after each upgrade of dropbear
sed -e "/sshd:x:/d" -i ./etc/shadow
if [ `grep "sshd:x:22:22" ./etc/passwd | wc -l` -eq 0 ]; then
    echo "sshd:x:22:22:sshd:/var/run/sshd:/bin/false" >> ./etc/passwd
    echo "sshd:x:22:sshd" >> ./etc/group
    echo "sshd:x:${ddd}:0:99999:7:::" >> ./etc/shadow
fi

if [ "${BR_FLAG}" -eq "1" ]; then
    if [ -x ./bin/bash ] && [ -f ./etc/profile.d/30-sysinfo.sh ]; then
        sed -e 's/\/bin\/ash/\/bin\/bash/' -i ./etc/passwd
    fi
    sync
fi
sed -e "s/option hw_flow '1'/option hw_flow '0'/" -i ./etc/config/turboacc
(
    cd etc/rc.d 
    rm -f S??shortcut-fe
    if grep "sfe_flow '1'" ../config/turboacc >/dev/null;then
        if find ../../lib/modules -name 'shortcut-fe-cm.ko';then
            ln -sf ../init.d/shortcut-fe S99shortcut-fe
        fi
    fi
)
eval tar czf .reserved/openwrt_config.tar.gz "${BACKUP_LIST}" 2>/dev/null

rm -f ./etc/part_size ./usr/bin/mk_newpart.sh
if  [ -x ./usr/sbin/balethirq.pl ]; then
    if  grep "balethirq.pl" "./etc/rc.local"; then
        echo "balance irq is enabled"
    else
        echo "enable balance irq"
        sed -e "/exit/i\/usr/sbin/balethirq.pl" -i ./etc/rc.local
    fi
fi
mv ./etc/rc.local ./etc/rc.local.orig

cat > ./etc/rc.local <<EOF
if [ ! -f /etc/rc.d/*dockerd ]; then
    /etc/init.d/dockerd enable
    /etc/init.d/dockerd start
fi
mv /etc/rc.local.orig /etc/rc.local
exec /etc/rc.local
exit
EOF

chmod 755 ./etc/rc.local*

#Mainline U-BOOT detection
FLASH_MAINLINE_UBOOT=0
if  [[ -n "${MAINLINE_UBOOT}" && -f "${P2}${MAINLINE_UBOOT}" ]]; then
    cat <<EOF
----------------------------------------------------------------------------------
Found an available mainline bootloader (Mainline u-boot), you can flash into EMMC.
----------------------------------------------------------------------------------
EOF
    while :; do
        if [[ "${AUTO_MAINLINE_UBOOT}" == "yes" ]]; then
            if  [[ "${K510}" -eq "1" ]]; then
                yn="y"
            else
                yn="n"
            fi
        elif [[ "${AUTO_MAINLINE_UBOOT}" == "no" ]]; then
                yn="n"
        else
            read -p "Please choose whether to write the mainline bootloader to EMMC?  y/n " yn
        fi

        case $yn in
            y|Y) FLASH_MAINLINE_UBOOT=1
                break
                ;;
            n|N) FLASH_MAINLINE_UBOOT=0
                break
                ;;
        esac
    done
fi

if  [[ "${FLASH_MAINLINE_UBOOT}" -eq "1" ]]; then
    echo -e "Write Mainline bootloader: [ ${MAINLINE_UBOOT} ]"
    dd if=${P2}${MAINLINE_UBOOT} of=/dev/${EMMC_NAME} bs=1 count=444 conv=fsync
    dd if=${P2}${MAINLINE_UBOOT} of=/dev/${EMMC_NAME} bs=512 skip=1 seek=1 conv=fsync
elif [[ -n "${ANDROID_UBOOT}" && -f "${P2}${ANDROID_UBOOT}" ]]; then
    echo -e "Write Android bootloader: [ ${ANDROID_UBOOT} ]"
    dd if=${P2}${ANDROID_UBOOT} of=/dev/${EMMC_NAME} bs=1 count=444 conv=fsync
    dd if=${P2}${ANDROID_UBOOT} of=/dev/${EMMC_NAME} bs=512 skip=1 seek=1 conv=fsync
else
    echo "Did not change the original bootloader."
fi

echo "Create etc snapshot -> .snapshots/etc-001"
btrfs subvolume snapshot -r etc .snapshots/etc-001

cd ${WORK_DIR}
 
echo "Start copying data， from [ ${P1} ] to [ /boot ] ..."
cd /boot
echo "Delete the old boot file ..."
rm -rf * && sync

echo "Copy the new boot file ... "
(cd ${P1} && tar cf - . ) | tar xf - 2>/dev/null
sync

if [ -f ${P1}/uInitrd ]; then
    i=1
    max_try=10
    while [ "${i}" -le "${max_try}" ]; do
        uInitrd_original=$(md5sum ${P1}/uInitrd | awk '{print $1}')
        uInitrd_new=$(md5sum uInitrd | awk '{print $1}')
        if [ "${uInitrd_original}" = "${uInitrd_new}" ]; then
            break
        else
            rm -f uInitrd && sync
            cp -f ${P1}/uInitrd uInitrd 2>/dev/null && sync
            let i++
            continue
        fi
    done
    [ "${i}" -eq "10" ] && echo "uInitrd file copy failed." && exit 1
else
    echo "uInitrd file is missing."
fi

if [ -f ${P1}/zImage ]; then
    i=1
    max_try=10
    while [ "${i}" -le "${max_try}" ]; do
        zImage_original=$(md5sum ${P1}/zImage | awk '{print $1}')
        zImage_new=$(md5sum zImage | awk '{print $1}')
        if [ "${zImage_original}" = "${zImage_new}" ]; then
            break
        else
            rm -f zImage && sync
            cp -f ${P1}/zImage zImage 2>/dev/null && sync
            let i++
            continue
        fi
    done
    [ "${i}" -eq "10" ] && echo "zImage file copy failed." && exit 1
else
    echo "zImage file is missing."
    exit 1
fi

rm -f s905_autoscript* aml_autoscript*

if  [ ${K510} -eq 1 ]; then
    if [ -f "u-boot.ext" ]; then
        cp -vf u-boot.ext u-boot.emmc
    elif [ -f ${P1}/${UBOOT_OVERLOAD} ]; then
        cp -vf ${P1}/${UBOOT_OVERLOAD} ${UBOOT_OVERLOAD}
        cp -vf ${P1}/${UBOOT_OVERLOAD} u-boot.ext
        cp -vf ${P1}/${UBOOT_OVERLOAD} u-boot.emmc
        chmod +x u-boot*
    fi
fi

mv -f boot-emmc.ini boot.ini
mv -f boot-emmc.cmd boot.cmd
mv -f boot-emmc.scr boot.scr
sync

echo "Update boot parameters ... "
if  [ -f /tmp/uEnv.txt ]; then
    lines=$(wc -l < /tmp/uEnv.txt)
    lines=$(( lines - 1 ))
    head -n $lines /tmp/uEnv.txt > uEnv.txt
    cat >> uEnv.txt <<EOF
APPEND=root=UUID=${NEW_ROOT_UUID} rootfstype=btrfs rootflags=compress=zstd console=ttyAML0,115200n8 console=tty0 no_console_suspend consoleblank=0 fsck.fix=yes fsck.repair=yes net.ifnames=0 cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory swapaccount=1
EOF
else
    cat > uEnv.txt <<EOF
LINUX=/zImage
INITRD=/uInitrd
FDT=${CUR_FDTFILE}
APPEND=root=UUID=${NEW_ROOT_UUID} rootfstype=btrfs rootflags=compress=zstd console=ttyAML0,115200n8 console=tty0 no_console_suspend consoleblank=0 fsck.fix=yes fsck.repair=yes net.ifnames=0 cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory swapaccount=1
EOF
fi
sync

cd $WORK_DIR
umount -f ${P1} ${P2} 2>/dev/null
losetup -D 2>/dev/null
rm -rf ${P1} ${P2} 2>/dev/null
rm -f ${IMG_NAME} 2>/dev/null
sync
wait

echo "Successfully updated, automatic restarting..."
sleep 3
reboot
exit 0

